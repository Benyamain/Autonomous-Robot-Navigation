
PINN Basics: Inertial Processing
Based on last week's unfinished inertia handling in the PINN Basics configuration, we tackled inertia in between other work. Since the /apply_joint_effort service doesn't directly control the overall speed zeroing, this gives us two new ideas: a) Force zeroing directly using the speedtopic . b) Zeroing the velocity by reversing the torque. It is very obvious that we prefer the second option, since forcing the use of a solution other than physical is not the original intention of our PINN. On further probing, I realized that since we had commented out a speed control plugin in the previous one that was causing the torque masking effect, we needed to add an additional plugin if we wanted to invoke the speed control service. So based on the above, we finally chose to reverse the torque to complete the closed-loop speed control.

(1) Speed monitoring + variable torque control
Based on the result of the previous process, we need to add a reverse torque before the torque goes to zero, and the impulse here needs to be strictly controlled to ensure that the cart can stop exactly at speed zero. I first introduce speed monitoring: the speeds of the left and right wheels are monitored in real time by subscribing to the topic /joint_states. But this doesn't work very well, because the moment is a constant value, the acceleration remains a constant at the end of the time of action, and even if the moment goes to zero, it doesn't stop immediately. For this reason, I introduced variable moment control. In practice, in Gazebo, the time-based variable moment action is not as smooth as in the hard world, but the frequency of application is determined by the refresh rate of the simulation software. And in testing it was found that the ROS service would cause port blocking if called too often. So I used a discrete service refresh, using a rate slightly below the Gazebo clock frequency to give the cart gradually decreasing acceleration/angular acceleration in time steps. This gave by far the best control in real-world performance.

(2) Time Synchronization + Floating Point Compatibility
In the previous phase of the task, we were actually using the fixed-time action command. In this phase, we realized real-time issuing of commands and real-time acting of torque through subscription/clock topic. However, there are some variables (especially time variables) that can only be used with int-type data, so I optimized for this to make floating point numbers acceptable.

(3) Multi-thread processing
Because of the thread blocking situation during the test, we have handled multi-threading. First of all, the fundamental reason I chose multithreading is that when dealing with Turtlebot3_burger having angular velocity, it requires two wheels to act with different moments, or even different action times, start times, and termination times, while having completely different reverse moments acting at the same time. Also using a separate thread in the time listening is effective in avoiding the main thread getting stuck. And even asynchronous invocation of services can be synchronized and waited for in the future after the decision maker imposes a command. Meanwhile, based on the problems we encountered in the test, the safe exit of the control thread can effectively avoid thread blocking.
